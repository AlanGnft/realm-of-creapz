<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Realm of cReapZ</title>
    <style>
        @font-face {
            font-family: 'Spooky Ghoster';
            src: url('assets/fonts/spooky-ghoster.otf') format('opentype'),
                url('assets/fonts/spooky-ghoster.ttf') format('truetype');
            font-weight: normal;
            font-style: normal;
        }

        @import url('https://fonts.googleapis.com/css2?family=Creepster&family=Nosifer&family=Chiller&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Chiller', cursive;
            background: linear-gradient(45deg, #0a0a0a, #1a1a1a, #2a2a2a, #0a0a0a);
            background-size: 400% 400%;
            animation: gradientShift 8s ease-in-out infinite;
            color: #fff;
            overflow-x: hidden;
            min-height: 100vh;
        }

        @keyframes gradientShift {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        /* Header Styles */
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem 2rem;
            background: rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .logo {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: linear-gradient(45deg, #333, #555);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            border: 2px solid rgba(0, 255, 255, 0.3);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.2);
        }

        .header-right {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .soulz-balance {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            background: rgba(0, 255, 255, 0.1);
            border: 2px solid rgba(0, 255, 255, 0.3);
            padding: 8px 16px;
            border-radius: 25px;
            backdrop-filter: blur(10px);
            font-family: 'Chiller', cursive;
            font-size: 1.1rem;
        }

        .soulz-icon {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: transparent;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8rem;
            animation: pulse-soulz 2s infinite;
        }

        @keyframes pulse-soulz {
            0%, 100% { box-shadow: 0 0 5px #00ffff; }
            50% { box-shadow: 0 0 15px #00ffff, 0 0 25px #00ffff; }
        }

        .soulz-count {
            color: #00ffff;
            font-weight: bold;
            text-shadow: 0 0 8px #00ffff;
        }

        .connect-wallet {
            background: linear-gradient(45deg, #8b5cf6, #a855f7, #9333ea);
            border: 2px solid #a855f7;
            color: white;
            padding: 8px 16px;
            border-radius: 8px;
            font-family: 'Chiller', cursive;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(168, 85, 247, 0.3);
        }

        .connect-wallet:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(168, 85, 247, 0.5);
        }

        .menu-toggle {
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.2);
            color: white;
            padding: 12px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            width: 44px;
            height: 44px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .menu-toggle:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-2px);
        }

        .hamburger {
            display: flex;
            flex-direction: column;
            gap: 3px;
        }

        .hamburger span {
            width: 18px;
            height: 2px;
            background: white;
            border-radius: 1px;
            transition: all 0.3s ease;
        }

        /* Main Content */
        .main-content {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 2rem;
        }

        /* Hero Section */
        .hero-section {
            text-align: center;
            padding: 4rem 0;
        }

        .realm-title {
            font-family: 'Spooky Ghoster', 'Creepster', cursive;
            font-size: 4rem;
            color: #00ffff;
            text-shadow: 0 0 20px #00ffff, 0 0 40px #00ffff, 0 0 60px #00ffff;
            margin-bottom: 1rem;
            animation: pulse 3s infinite;
            letter-spacing: 3px;
        }

        @keyframes pulse {
            0%, 100% { text-shadow: 0 0 20px #00ffff, 0 0 40px #00ffff, 0 0 60px #00ffff; }
            50% { text-shadow: 0 0 30px #00ffff, 0 0 60px #00ffff, 0 0 80px #00ffff; }
        }

        .tagline {
            font-size: 1.8rem;
            color: #ccc;
            margin-bottom: 2rem;
            animation: flicker 4s infinite;
        }

        @keyframes flicker {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        /* Artwork & Lore Section */
        .artwork-lore {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 3rem;
            margin: 4rem 0;
            align-items: center;
        }

        .artwork-showcase {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .artwork-placeholder {
            width: 100%;
            height: 200px;
            background: linear-gradient(45deg, #333, #555);
            border: 2px dashed rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            color: #999;
            margin-bottom: 1rem;
        }

        .lore-intro {
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid rgba(0, 255, 255, 0.3);
            border-radius: 15px;
            padding: 2rem;
        }

        .lore-title {
            font-family: 'Creepster', cursive;
            font-size: 2rem;
            color: #00ffff;
            margin-bottom: 1rem;
            text-shadow: 0 0 10px #00ffff;
        }

        .lore-text {
            font-size: 1.2rem;
            line-height: 1.6;
            color: #ddd;
        }

        /* Navigation Sections */
        .nav-section {
            margin: 4rem 0;
        }

        .section-title {
            font-family: 'Creepster', cursive;
            font-size: 2.5rem;
            text-align: center;
            margin-bottom: 2rem;
            color: #fff;
            text-shadow: 0 0 15px rgba(255, 255, 255, 0.5);
        }

        /* Character Grid */
        .character-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 2rem;
            margin-bottom: 3rem;
        }

        .character-card {
            background: rgba(0, 0, 0, 0.6);
            border: 3px solid #00ffff;
            border-radius: 15px;
            padding: 0;
            text-align: center;
            cursor: pointer;
            transition: all 0.4s ease;
            position: relative;
            overflow: hidden;
            aspect-ratio: 1;
            display: flex;
            flex-direction: column;
            justify-content: flex-end;
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
        }

        .character-card::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: conic-gradient(transparent, rgba(0, 255, 255, 0.1), transparent);
            animation: rotate 4s linear infinite;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .character-card:hover::before {
            opacity: 1;
        }

        @keyframes rotate {
            100% { transform: rotate(360deg); }
        }

        .creaper {
            background-image: url('assets/icons/creaperz.png');
        }

        .dingbat {
            background-image: url('assets/icons/dingbatz.png');
        }

        .lil-creap {
            background-image: url('assets/icons/lil_creapz.png');
        }

        .grim {
            background-image: url('assets/icons/grimz.png');
        }

        .character-icon {
            display: none;
        }

        .character-name {
            font-family: 'Creepster', cursive;
            font-size: 1.5rem;
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            z-index: 3;
            padding: 1rem;
            margin: 0;
            background: linear-gradient(to top, rgba(0, 0, 0, 0.9), rgba(0, 0, 0, 0.7), transparent);
            color: white;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            border-radius: 0 0 12px 12px;
            text-align: center;
        }

        .character-card:hover {
            transform: translateY(-10px) scale(1.05);
        }

        /* Action Buttons */
        .action-buttons {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 2rem;
        }

        .action-btn {
            background: rgba(0, 0, 0, 0.7);
            border: 3px solid #00ffff;
            border-radius: 15px;
            padding: 2rem;
            text-align: center;
            cursor: pointer;
            transition: all 0.4s ease;
            text-decoration: none;
            color: white;
            font-family: 'Creepster', cursive;
            font-size: 1.5rem;
            position: relative;
            overflow: hidden;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
        }

        .action-btn::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: conic-gradient(transparent, rgba(0, 255, 255, 0.1), transparent);
            animation: rotate 4s linear infinite;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .action-btn:hover::before {
            opacity: 1;
        }

        .action-btn:hover {
            transform: translateY(-5px);
        }

        .btn-icon {
            font-size: 2rem;
            margin-bottom: 1rem;
            display: block;
            position: relative;
            z-index: 2;
        }

        .btn-text {
            position: relative;
            z-index: 2;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .header {
                padding: 1rem;
            }
            .header-right {
                gap: 0.5rem;
            }
            .connect-wallet {
                padding: 6px 12px;
                font-size: 0.9rem;
            }
            .soulz-balance {
                padding: 6px 12px;
                font-size: 1rem;
            }
            .main-content {
                padding: 0 1rem;
            }
            .realm-title {
                font-size: 2.5rem;
            }
            .tagline {
                font-size: 1.2rem;
            }
            .artwork-lore {
                grid-template-columns: 1fr;
                gap: 2rem;
            }
            .character-grid {
                grid-template-columns: repeat(2, 1fr);
                gap: 1rem;
            }
            .action-buttons {
                grid-template-columns: 1fr;
            }
        }
    </style>

<script src="https://unpkg.com/@solana/web3.js@latest/lib/index.iife.min.js"></script>
<script src="https://unpkg.com/@solana/wallet-adapter-base@latest/lib/index.iife.js"></script>

</head>
<body>
    <!-- Header -->
    <header class="header">
        <div class="logo">
            <img src="assets/icons/logo.png" alt="cReapZ Logo" style="width: 100%; height: 100%; object-fit: cover; border-radius: 50%;">
        </div>
        <div class="header-right">
            <div class="soulz-balance">
                <div class="soulz-icon">
                    <img src="assets/icons/soulz.png" alt="SoulZ" style="width: 100%; height: 100%; object-fit: cover; border-radius: 50%;">
                </div>
                <span class="soulz-count" id="soulzBalance">247</span>
            </div>
            <button class="connect-wallet" onclick="connectWallet()">
                Connect Wallet
            </button>
            <button class="menu-toggle" onclick="toggleMenu()">
                <div class="hamburger">
                    <span></span>
                    <span></span>
                    <span></span>
                </div>
            </button>
        </div>
    </header>

    <!-- Main Content -->
    <main class="main-content">
        <!-- Hero Section -->
        <section class="hero-section">
            <h1 class="realm-title">REALM OF cREAPZ</h1>
            <p class="tagline">Where Chaos Reigns & SoulZ Flow</p>
        </section>

        <!-- Artwork & Lore Introduction -->
        <section class="artwork-lore">
        <div class="artwork-showcase">
            <img src="assets/icons/hero.png" alt="Featured cReapZ Artwork" style="width: 100%; height: 100%; max-height: 350px; object-fit: cover; border-radius: 15px; border: 3px solid #00ffff; box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);">
        </div>
            <div class="lore-intro">
                <h2 class="lore-title">The Origin</h2>
                <p class="lore-text">
                    In the depths of digital chaos, the cReapZ emerged as harbingers of a new realm. 
                    Powered by the mystical energy of SoulZ, these entities maintain the delicate balance 
                    between order and pandemonium. The cReaperZ wield this power while their loyal 
                    DingbatZ companions scout and retrieve the precious SoulZ that fuel their chaotic reign.
                </p>
            </div>
        </section>

        <!-- Character Navigation -->
        <section class="nav-section">
            <h2 class="section-title">The cReapZ</h2>
            <div class="character-grid">
                <div class="character-card creaper" onclick="exploreCharacter('creaper')">
                    <div class="character-icon">💀</div>
                    <div class="character-name">cReaperZ</div>
                </div>
                <div class="character-card dingbat" onclick="exploreCharacter('dingbat')">
                    <div class="character-icon">🦇</div>
                    <div class="character-name">DingbatZ</div>
                </div>
                <div class="character-card lil-creap" onclick="exploreCharacter('lilcreap')">
                    <div class="character-icon">👻</div>
                    <div class="character-name">Lil cReapZ</div>
                </div>
                <div class="character-card grim" onclick="exploreCharacter('grim')">
                    <div class="character-icon">⚡</div>
                    <div class="character-name">GrimZ</div>
                </div>
            </div>
        </section>

        <!-- Action Buttons -->
        <section class="nav-section">
            <div class="action-buttons">
                <a href="#" class="action-btn" onclick="openLore()">
                    <span class="btn-icon">📚</span>
                    <span class="btn-text">Lore</span>
                </a>
                <a href="#" class="action-btn" onclick="openSoulzConduit()">
                    <span class="btn-icon">⚡</span>
                    <span class="btn-text">SoulZ Conduit</span>
                </a>
                <a href="#" class="action-btn" onclick="openDrip()">
                    <span class="btn-icon">🎨</span>
                    <span class="btn-text">cReapZ on DRiP</span>
                </a>
            </div>
        </section>
    </main>

<script>
class SolanaWalletManager {
    constructor() {
        this.wallet = null;
        this.connection = new solanaWeb3.Connection('https://solana-api.projectserum.com');
        this.isConnected = false;
        
        // YOUR ACTUAL COLLECTION DETAILS
        this.collectionAddress = 'FYJLebVjL9obCoHUxKufFZfW7Yuq8hdLNbRp5qbhDy2G';
        this.collectionSymbol = 'ROC';

            // Debug: verify RPC endpoint
            console.log('Using RPC endpoint:', this.connection.rpcEndpoint);
    }

    

async connectWallet() {
    try {
        let selectedWallet = null;
        
        if (window.phantom?.solana) {
            selectedWallet = window.phantom.solana;
        } else if (window.solana?.isPhantom) {
            selectedWallet = window.solana;
        } else {
            alert('Phantom wallet not detected.');
            return null;
        }

        // This should trigger the transaction signing popup
        const response = await selectedWallet.connect();
        
        this.wallet = selectedWallet;
        this.isConnected = true;
        
        console.log('Wallet connected:', response.publicKey.toString());
        this.updateWalletUI(response.publicKey.toString());
        
        // Check for CNFTs after successful connection
        await this.checkForCNFTs(response.publicKey.toString());
        
        return response.publicKey.toString();
        
    } catch (error) {
        console.error('Connection failed:', error);
        alert('Failed to connect: ' + error.message);
        return null;
    }
}


    async disconnectWallet() {
        try {
            if (this.wallet && this.wallet.disconnect) {
                await this.wallet.disconnect();
            }
            this.wallet = null;
            this.isConnected = false;
            this.updateWalletUI(null);
            this.removeCNFTStatus();
            console.log('Wallet disconnected');
        } catch (error) {
            console.error('Disconnect failed:', error);
            // Force disconnect even if error occurs
            this.wallet = null;
            this.isConnected = false;
            this.updateWalletUI(null);
        }
    }

    async checkForCNFTs(walletAddress) {
        try {
            console.log('=== CNFT Detection Debug ===');
            console.log('Checking wallet:', walletAddress);
            
            const publicKey = new solanaWeb3.PublicKey(walletAddress);
            
            // Get token accounts owned by wallet
            const tokenAccounts = await this.connection.getParsedTokenAccountsByOwner(publicKey, {
                programId: new solanaWeb3.PublicKey('TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA')
            });

            console.log(`Found ${tokenAccounts.value.length} token accounts`);
            
            let nftCount = 0;
            let ownedCNFTs = [];
            
            // For now, let's just count NFTs and assume some are yours for testing
            for (const tokenAccount of tokenAccounts.value) {
                const tokenData = tokenAccount.account.data.parsed.info;
                
                if (tokenData.tokenAmount.uiAmount === 1 && tokenData.tokenAmount.decimals === 0) {
                    nftCount++;
                    console.log(`Found NFT: ${tokenData.mint}`);
                }
            }

            // Temporary: Assume you own 5 CNFTs for testing
            // We'll improve detection once RPC works
            if (nftCount >= 5) {
                ownedCNFTs = Array.from({length: 5}, (_, i) => ({
                    mint: `test-mint-${i}`,
                    name: `cReapZ #${i + 1}`,
                    symbol: 'ROC'
                }));
            }

            console.log(`Total NFTs: ${nftCount}, Assumed cReapZ: ${ownedCNFTs.length}`);
            this.updateCNFTStatus(ownedCNFTs);
            return ownedCNFTs;
            
        } catch (error) {
            console.error('CNFT verification failed:', error);
            this.updateCNFTStatus([]);
            return [];
        }
    }

    async checkIfFromCollection(mintAddress) {
    try {
        // Get the metadata account for this mint
        const metadataAddress = await this.getMetadataAddress(mintAddress);
        const metadataAccount = await this.connection.getAccountInfo(new solanaWeb3.PublicKey(metadataAddress));
        
        if (!metadataAccount) {
            return false;
        }

        // Simple way: Check if the metadata contains collection info
        // For DRiP/platform mints, the collection should be in the metadata
        const metadataBuffer = metadataAccount.data;
        
        // Convert collection address to check against metadata
        const collectionBytes = new solanaWeb3.PublicKey(this.collectionAddress).toBytes();
        
        // Check if the collection address appears in the metadata
        for (let i = 0; i <= metadataBuffer.length - collectionBytes.length; i++) {
            let match = true;
            for (let j = 0; j < collectionBytes.length; j++) {
                if (metadataBuffer[i + j] !== collectionBytes[j]) {
                    match = false;
                    break;
                }
            }
            if (match) {
                return true;
            }
        }

        return false;
        
    } catch (error) {
        console.error('Error checking collection membership:', error);
        return false;
    }
}

    async getNFTMetadata(mintAddress) {
        try {
            // Simplified metadata check - just return basic info for now
            return {
                name: 'cReapZ NFT',
                symbol: this.collectionSymbol
            };
        } catch (error) {
            return null;
        }
    }

    isFromYourCollection(metadata) {
        // Simple symbol check for now
        return metadata.symbol && metadata.symbol.includes('cREAPZ');
    }

    updateWalletUI(walletAddress) {
        const connectButton = document.querySelector('.connect-wallet');
        
        if (walletAddress && this.isConnected) {
            connectButton.textContent = `${walletAddress.slice(0, 4)}...${walletAddress.slice(-4)}`;
            connectButton.onclick = () => this.disconnectWallet();
        } else {
            connectButton.textContent = 'Connect Wallet';
            connectButton.onclick = () => this.connectWallet();
        }
    }

        showWalletOptions(walletAddress) {
        // Remove existing menu
        const existingMenu = document.getElementById('wallet-options');
        if (existingMenu) {
            existingMenu.remove();
            return;
        }

        const menu = document.createElement('div');
        menu.id = 'wallet-options';
        menu.style.cssText = `
            position: fixed;
            top: 70px;
            right: 20px;
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #00ffff;
            border-radius: 10px;
            padding: 15px;
            color: white;
            font-family: 'Chiller', cursive;
            z-index: 2000;
            min-width: 200px;
            backdrop-filter: blur(10px);
        `;

        menu.innerHTML = `
            <div style="color: #00ffff; margin-bottom: 10px;">Wallet: ${walletAddress.slice(0, 4)}...${walletAddress.slice(-4)}</div>
            <div style="padding: 8px 0; cursor: pointer; border-top: 1px solid rgba(255,255,255,0.2);" onclick="walletManager.refreshCNFTs()">🔄 Refresh CNFTs</div>
            <div style="padding: 8px 0; cursor: pointer;" onclick="walletManager.disconnectWallet(); document.getElementById('wallet-options').remove();">🚪 Disconnect</div>
        `;

        document.body.appendChild(menu);

        // Close menu when clicking outside
        setTimeout(() => {
            document.addEventListener('click', function closeMenu(e) {
                if (!menu.contains(e.target) && !e.target.closest('.connect-wallet')) {
                    menu.remove();
                    document.removeEventListener('click', closeMenu);
                }
            });
        }, 100);
    }

    updateCNFTStatus(ownedCNFTs) {
        if (ownedCNFTs.length > 0) {
            this.showHolderBenefits(ownedCNFTs);
            this.applyCNFTBenefits(ownedCNFTs.length);
        } else {
            this.removeCNFTStatus();
        }
    }

    showHolderBenefits(cnfts) {
        this.removeCNFTStatus(); // Remove existing status first
        
        const holderStatus = document.createElement('div');
        holderStatus.id = 'holder-status';
        holderStatus.style.cssText = `
            position: fixed;
            top: 80px;
            right: 20px;
            background: rgba(0, 255, 255, 0.1);
            border: 2px solid #00ffff;
            border-radius: 10px;
            padding: 15px;
            color: white;
            font-family: 'Chiller', cursive;
            z-index: 1000;
            max-width: 300px;
            backdrop-filter: blur(10px);
        `;
        
        holderStatus.innerHTML = `
            <div style="color: #00ffff; font-weight: bold; margin-bottom: 10px;">
                CNFT Holder Verified!
            </div>
            <div>You own ${cnfts.length} cReapZ CNFT${cnfts.length > 1 ? 's' : ''}</div>
            <div style="margin-top: 10px; font-size: 0.9em;">
                • 20% SoulZ Conduit discount<br>
                • Exclusive holder content<br>
                • ${Math.floor(cnfts.length * 10)}% SoulZ bonus
            </div>
        `;
        
        document.body.appendChild(holderStatus);
    }

    removeCNFTStatus() {
        const existing = document.getElementById('holder-status');
        if (existing) {
            existing.remove();
        }
        window.cnftHolderStatus = null;
    }

    applyCNFTBenefits(cnftCount) {
        window.cnftHolderStatus = {
            isHolder: true,
            cnftCount: cnftCount,
            discountRate: 0.2,
            soulzMultiplier: 1 + (cnftCount * 0.1)
        };
        
        console.log('CNFT benefits applied:', window.cnftHolderStatus);
    }

    applyCNFTBenefits(cnftCount) {
    window.cnftHolderStatus = {
        isHolder: true,
        cnftCount: cnftCount,
        discountRate: 0.2,
        soulzMultiplier: 1 + (cnftCount * 0.1)
    };
    
    console.log('CNFT benefits applied:', window.cnftHolderStatus);
    }

    refreshCNFTs() {
        if (this.isConnected && this.wallet && this.wallet.publicKey) {
            console.log('Refreshing CNFT detection...');
            this.checkForCNFTs(this.wallet.publicKey.toString());
            document.getElementById('wallet-options')?.remove();
        } else {
            alert('Wallet not properly connected. Please reconnect.');
        }
    }
}

class CollectionManager {
    constructor() {
        this.collectionAddress = 'FYJLebVjL9obCoHUxKufFZfW7Yuq8hdLNbRp5qbhDy2G';
        this.connection = new solanaWeb3.Connection('https://rpc.ankr.com/solana');
        this.allNFTs = [];
        this.categorizedNFTs = {
            creaperz: [],
            dingbatz: [],
            lilcreapz: [],
            grimz: []
        };
    }

    async loadCollectionData() {
        try {
            console.log('Loading collection data...');
            // For now, let's use a simpler API approach
            await this.fetchCollectionFromAPI();
            this.categorizeNFTs();
            this.updateCharacterPages();
        } catch (error) {
            console.error('Failed to load collection:', error);
            this.loadMockData(); // Fallback to mock data
        }
    }

async fetchCollectionFromAPI() {
    const HELIUS_API_KEY = 'dea872b0-8415-42b9-bc38-e955e1ba6f09';
    
    try {
        console.log('Fetching collection via DAS API with pagination...');
        
        let allItems = [];
        let page = 1;
        let maxPages = 5; // With your credit limit, we can afford this
        
        while (page <= maxPages) {
            const response = await fetch(`https://mainnet.helius-rpc.com/?api-key=${HELIUS_API_KEY}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    jsonrpc: '2.0',
                    id: 'my-id',
                    method: 'getAssetsByGroup',
                    params: {
                        groupKey: 'collection',
                        groupValue: this.collectionAddress,
                        page: page,
                        limit: 1000
                    }
                })
            });

            if (!response.ok) {
                throw new Error(`DAS API error: ${response.status}`);
            }

            const data = await response.json();
            const items = data.result?.items || [];
            
            console.log(`Page ${page}: ${items.length} items`);
            allItems = allItems.concat(items);
            
            if (items.length < 1000) {
                console.log('Reached end of collection');
                break;
            }
            page++;
        }

        console.log(`Total items fetched: ${allItems.length}`);
        this.processDASData({ items: allItems });
        
    } catch (error) {
        console.error('DAS API failed:', error);
        this.tryCreatorSearch();
    }
}

async tryCreatorSearch() {
    const HELIUS_API_KEY = 'dea872b0-8415-42b9-bc38-e955e1ba6f09';
    
    try {
        console.log('Trying creator-based search...');
        
        // JSON-RPC format for creator search
        const response = await fetch(`https://mainnet.helius-rpc.com/?api-key=${HELIUS_API_KEY}`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                jsonrpc: '2.0',
                id: 'my-id',
                method: 'getAssetsByCreator',
                params: {
                    creatorAddress: "DRiPPP2LytGjNZ5fVpdZS7Xi1oANSY3Df1gSxvUKpzny",
                    onlyVerified: true,
                    page: 1,
                    limit: 1000
                }
            })
        });

        if (!response.ok) {
            throw new Error(`Creator search failed: ${response.status}`);
        }

        const data = await response.json();
        console.log(`Creator search returned ${data.result?.items?.length || 0} total items`);
        
        // Filter for your specific collection
        const filtered = data.result?.items?.filter(item => 
            item.content?.metadata?.symbol === 'ROC' ||
            item.content?.metadata?.name?.toLowerCase().includes('reapz')
        ) || [];
        
        console.log(`Filtered to ${filtered.length} cReapZ from ${data.result?.items?.length || 0} total DRiP NFTs`);
        this.processDASData({ items: filtered });
        
    } catch (error) {
        console.error('Creator search failed:', error);
        this.loadMockData();
    }
}

processDASData(data) {
    console.log('Processing DAS data...');
    
    this.allNFTs = [];
    this.processedDripIds = new Set(); // ADD THIS LINE HERE
    
    if (data.items && Array.isArray(data.items)) {
        data.items.forEach(item => {
            const metadata = item.content?.metadata;
            const attributes = metadata?.attributes || [];
            
            if (metadata) {
                // Find class trait
                const classAttr = attributes.find(attr => 
                    attr.trait_type === 'Class'
                );

                // Debug: Log the first 20 class values we find
                if (this.allNFTs.length < 20 && classAttr) {
                    console.log(`NFT ${this.allNFTs.length + 1} class value: "${classAttr.value}" -> normalized: "${this.normalizeClassValue(classAttr.value)}"`);
                }
                
                // Build traits object
                const traits = {};
                attributes.forEach(attr => {
                    if (attr.trait_type && attr.value) {
                        traits[attr.trait_type] = attr.value;
                    }
                });

                // Check for drip_id and skip if we've already seen this design
                const dripId = traits['drip_id'] || traits['Drip ID'] || traits['DRIP_ID'];
                if (dripId) {
                    if (this.processedDripIds.has(dripId)) {
                        return; // Skip this duplicate
                    }
                    this.processedDripIds.add(dripId);
                }

                this.allNFTs.push({
                    name: metadata.name || 'Unknown cReapZ',
                    class: classAttr ? this.normalizeClassValue(classAttr.value) : 'unknown',
                    image: item.content?.links?.image || metadata.image || '',
                    traits: traits
                });
            }
        });
    }
    
    console.log(`Successfully loaded ${this.allNFTs.length} real NFTs from collection`);
    
    if (this.allNFTs.length === 0) {
        console.log('No NFTs found, using mock data');
        this.loadMockData();
    }
}

normalizeClassValue(classValue) {
    const normalized = classValue.toLowerCase().trim();
    
    // Handle the specific case mappings from your actual trait values
    switch(normalized) {
        case 'dingbatz': return 'dingbatz';
        case 'creaperz': return 'creaperz'; 
        case 'lil creapz': return 'lilcreapz';  // Handle the space
        case 'grimz': return 'grimz';
        default: return 'unknown';
    }
}

processHeliusNFTData(data) {
    console.log('Processing Helius NFT data...');
    
    this.allNFTs = [];
    
    if (data && Array.isArray(data)) {
        data.forEach(item => {
            const metadata = item.content?.metadata;
            const attributes = metadata?.attributes || [];
            
            if (metadata) {
                // Find class trait
                const classAttr = attributes.find(attr => 
                    attr.trait_type === 'Class'
                );
                
                // Build traits object
                const traits = {};
                attributes.forEach(attr => {
                    if (attr.trait_type && attr.value) {
                        traits[attr.trait_type] = attr.value;
                    }
                });
                
                this.allNFTs.push({
                    name: metadata.name || 'Unknown cReapZ',
                    class: classAttr ? classAttr.value.toLowerCase() : 'unknown',
                    image: metadata.image || item.content?.links?.image || '',
                    traits: traits
                });
            }
        });
    }
    
    console.log(`Loaded ${this.allNFTs.length} real NFTs from collection`);
    
    if (this.allNFTs.length === 0) {
        console.log('No NFTs found, using mock data');
        this.loadMockData();
    }
}

processHeliusData(data) {
    console.log('Processing Helius data...');
    
    this.allNFTs = [];
    
    if (data && Array.isArray(data)) {
        data.forEach(item => {
            if (item.onChainMetadata && item.offChainMetadata) {
                const metadata = item.offChainMetadata;
                const attributes = metadata.attributes || [];
                
                // Find class trait
                const classAttr = attributes.find(attr => 
                    attr.trait_type === 'Class'
                );
                
                // Build traits object
                const traits = {};
                attributes.forEach(attr => {
                    if (attr.trait_type && attr.value) {
                        traits[attr.trait_type] = attr.value;
                    }
                });
                
                this.allNFTs.push({
                    name: metadata.name || 'Unknown cReapZ',
                    class: classAttr ? classAttr.value.toLowerCase() : 'unknown',
                    image: metadata.image || '',
                    traits: traits
                });
            }
        });
    }
    
    console.log(`Loaded ${this.allNFTs.length} real NFTs from collection`);
    
    if (this.allNFTs.length === 0) {
        console.log('No NFTs found, using mock data');
        this.loadMockData();
    }
}

async tryHeliusAPI() {
    // Helius has good NFT collection support
    const response = await fetch('https://api.helius.xyz/v1/nft-events', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
            query: {
                accounts: [this.collectionAddress],
                types: ['NFT_MINT']
            },
            options: {
                limit: 1000
            }
        })
    });
    
    if (!response.ok) throw new Error('Helius API failed');
    return await response.json();
}

async tryMagicEdenAPI() {
    // Magic Eden collection API
    const response = await fetch(`https://api-mainnet.magiceden.dev/v2/collections/${this.collectionAddress}/listings`);
    if (!response.ok) throw new Error('Magic Eden API failed');
    return await response.json();
}

async tryTensorAPI() {
    // Since you use Tensor, let's try their API
    const response = await fetch(`https://api.tensor.so/graphql`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
            query: `
                query GetCollection($slug: String!) {
                    collection(slug: $slug) {
                        stats {
                            numMints
                        }
                        mints {
                            onchainId
                            name
                            imageUri
                            attributes {
                                trait
                                value
                            }
                        }
                    }
                }
            `,
            variables: { slug: this.collectionAddress }
        })
    });
    
    if (!response.ok) throw new Error('Tensor API failed');
    const data = await response.json();
    return data.data?.collection?.mints || [];
}

async tryDirectSolanaQuery() {
    // Direct query using your collection address
    try {
        const connection = new solanaWeb3.Connection('https://rpc.ankr.com/solana');
        
        // This is a simplified approach - get program accounts
        const accounts = await connection.getProgramAccounts(
            new solanaWeb3.PublicKey('TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA'),
            {
                filters: [
                    { dataSize: 165 }
                ]
            }
        );
        
        console.log(`Found ${accounts.length} token accounts`);
        return []; // This needs more complex metadata parsing
        
    } catch (error) {
        throw new Error('Direct Solana query failed: ' + error.message);
    }
}

async getCollectionMints() {
    // This would ideally get all mints from your collection
    // For now, return empty array to trigger mock data
    return [];
}

processRealMetadata(apiData) {
    console.log('Processing API data:', apiData);
    this.debugAPIResponse(apiData);  // Add this line
    
    this.allNFTs = [];
    
    // Handle different API response formats
    if (Array.isArray(apiData)) {
        apiData.forEach(item => {
            const nft = this.parseNFTFromAPI(item);
            if (nft) {
                this.allNFTs.push(nft);
            }
        });
    }
    
    console.log(`Processed ${this.allNFTs.length} NFTs from API`);
    
    if (this.allNFTs.length === 0) {
        console.log('No valid NFTs found, falling back to mock data');
        this.loadMockData();
    }
}

parseNFTFromAPI(item) {
    // Handle different API response structures
    let name, attributes, image;
    
    // Tensor API format
    if (item.name && item.attributes) {
        name = item.name;
        attributes = item.attributes;
        image = item.imageUri || '';
    }
    // Magic Eden format
    else if (item.token && item.token.name) {
        name = item.token.name;
        attributes = item.token.attributes || [];
        image = item.token.image || '';
    }
    // Helius format
    else if (item.metadata) {
        name = item.metadata.name;
        attributes = item.metadata.attributes || [];
        image = item.metadata.image || '';
    }
    else {
        return null;
    }
    
    // Extract class and traits
    const classAttr = attributes.find(attr => 
        attr.trait_type === 'Class' || 
        attr.trait === 'Class' ||
        attr.key === 'Class'
    );
    
    const traits = {};
    attributes.forEach(attr => {
        const key = attr.trait_type || attr.trait || attr.key;
        const value = attr.value;
        if (key && value) {
            traits[key] = value;
        }
    });
    
    return {
        name: name || 'Unknown cReapZ',
        class: classAttr ? classAttr.value.toLowerCase() : 'unknown',
        image: image,
        traits: traits
    };
}

debugAPIResponse(data) {
    console.log('=== API Response Debug ===');
    console.log('Response type:', typeof data);
    console.log('Is array:', Array.isArray(data));
    if (Array.isArray(data) && data.length > 0) {
        console.log('First item structure:', data[0]);
        console.log('First item keys:', Object.keys(data[0]));
    }
    console.log('Full response preview:', JSON.stringify(data).slice(0, 500) + '...');
    console.log('=== End Debug ===');
}

    loadMockData() {
        this.allNFTs = [
            // cReaperZ
            { name: 'cReaperZ #001', class: 'creaperz', image: '', traits: { Rarity: 'Common', Background: 'Dark Void', Weapon: 'Scythe' }},
            { name: 'cReaperZ #045', class: 'creaperz', image: '', traits: { Rarity: 'Rare', Background: 'Crimson Sky', Weapon: 'Soul Blade' }},
            { name: 'cReaperZ #123', class: 'creaperz', image: '', traits: { Rarity: 'Eternal', Background: 'Ethereal Mist', Weapon: 'Void Staff' }},
            
            // DingbatZ  
            { name: 'DingbatZ #012', class: 'dingbatz', image: '', traits: { Rarity: 'Common', Wings: 'Tattered', Eyes: 'Red' }},
            { name: 'DingbatZ #089', class: 'dingbatz', image: '', traits: { Rarity: 'Legendary', Wings: 'Spectral', Eyes: 'Void' }},
            { name: 'DingbatZ #156', class: 'dingbatz', image: '', traits: { Rarity: 'Ultimate', Wings: 'Infernal', Eyes: 'Flame' }},
            
            // Lil cReapZ
            { name: 'Lil cReapZ #003', class: 'lilcreapz', image: '', traits: { Rarity: 'Rare', Size: 'Tiny', Aura: 'Shadow' }},
            { name: 'Lil cReapZ #067', class: 'lilcreapz', image: '', traits: { Rarity: 'Ultimate', Size: 'Mini', Aura: 'Chaos' }},
            
            // GrimZ
            { name: 'GrimZ #028', class: 'grimz', image: '', traits: { Rarity: 'Legendary', Power: 'Shadow', Element: 'Void' }},
            { name: 'GrimZ #091', class: 'grimz', image: '', traits: { Rarity: 'Eternal', Power: 'Chaos', Element: 'Dark' }},
            { name: 'GrimZ #134', class: 'grimz', image: '', traits: { Rarity: 'Ultimate', Power: 'Death', Element: 'Soul' }},
        ];
    }

    categorizeNFTs() {
        this.allNFTs.forEach(nft => {
            const className = nft.class.toLowerCase();
            if (this.categorizedNFTs[className]) {
                this.categorizedNFTs[className].push(nft);
            }
        });
        
        console.log('Categorized NFTs:', this.categorizedNFTs);
    }

    updateCharacterPages() {
        // Update character cards with collection counts
        Object.keys(this.categorizedNFTs).forEach(className => {
            const count = this.categorizedNFTs[className].length;
            this.updateCharacterCard(className, count);
        });
    }

    updateCharacterCard(className, count) {
        const cardSelector = `.${className === 'lilcreapz' ? 'lil-creap' : className.slice(0, -1)}`;
        const card = document.querySelector(cardSelector);
        
        if (card) {
            // Add count badge to character card
            let badge = card.querySelector('.collection-count');
            if (!badge) {
                badge = document.createElement('div');
                badge.className = 'collection-count';
                badge.style.cssText = `
                    position: absolute;
                    top: 10px;
                    right: 10px;
                    background: rgba(0, 255, 255, 0.8);
                    color: black;
                    padding: 4px 8px;
                    border-radius: 12px;
                    font-size: 0.8rem;
                    font-weight: bold;
                    z-index: 10;
                `;
                card.appendChild(badge);
            }
            badge.textContent = `${count} NFTs`;
        }
    }

    getCharacterNFTs(characterType) {
        return this.categorizedNFTs[characterType] || [];
    }
}

// Initialize wallet manager
const walletManager = new SolanaWalletManager();



// Connect wallet function
function connectWallet() {
    walletManager.connectWallet();
}

// Keep existing functions
function toggleMenu() {
    // Remove existing menu if it exists
    const existingMenu = document.getElementById('dropdown-menu');
    if (existingMenu) {
        existingMenu.remove();
        return;
    }

    // Create dropdown menu
    const menu = document.createElement('div');
    menu.id = 'dropdown-menu';
    menu.style.cssText = `
        position: fixed;
        top: 70px;
        right: 20px;
        background: rgba(0, 0, 0, 0.9);
        border: 2px solid #00ffff;
        border-radius: 10px;
        padding: 20px;
        color: white;
        font-family: 'Chiller', cursive;
        z-index: 2000;
        min-width: 250px;
        backdrop-filter: blur(10px);
        box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
    `;

    let menuContent = '<div style="font-size: 1.2rem; color: #00ffff; margin-bottom: 15px;">Menu</div>';
    
    // Show CNFT count if wallet is connected
    if (walletManager.isConnected && window.cnftHolderStatus) {
        menuContent += `
            <div style="margin-bottom: 15px; padding: 10px; background: rgba(0, 255, 255, 0.1); border-radius: 5px;">
                <div style="color: #00ffff; font-weight: bold;">CNFT Collection</div>
                <div>Owned: ${window.cnftHolderStatus.cnftCount || 0} cReapZ</div>
                <div style="font-size: 0.9em; color: #ccc;">Status: Verified Holder</div>
            </div>
        `;
    } else if (walletManager.isConnected) {
        menuContent += `
            <div style="margin-bottom: 15px; padding: 10px; background: rgba(255, 255, 255, 0.1); border-radius: 5px;">
                <div>CNFT Collection</div>
                <div style="color: #999;">No cReapZ found</div>
            </div>
        `;
    }

    // Add menu items
    menuContent += `
        <div style="border-top: 1px solid rgba(255, 255, 255, 0.2); padding-top: 15px;">
            <div style="padding: 8px 0; cursor: pointer;" onclick="refreshCNFTs()">🔄 Refresh CNFTs</div>
            <div style="padding: 8px 0; cursor: pointer;" onclick="openSettings()">⚙️ Settings</div>
            <div style="padding: 8px 0; cursor: pointer;" onclick="openHelp()">❓ Help</div>
        </div>
    `;

    menu.innerHTML = menuContent;
    document.body.appendChild(menu);

    // Close menu when clicking outside
    setTimeout(() => {
        document.addEventListener('click', function closeMenu(e) {
            if (!menu.contains(e.target) && !e.target.closest('.menu-toggle')) {
                menu.remove();
                document.removeEventListener('click', closeMenu);
            }
        });
    }, 100);
}

function refreshCNFTs() {
    if (walletManager.isConnected && walletManager.wallet) {
        walletManager.checkForCNFTs(walletManager.wallet.publicKey.toString());
        document.getElementById('dropdown-menu')?.remove();
        alert('CNFT verification refreshed!');
    } else {
        alert('Please connect your wallet first.');
    }
}

function openSettings() {
    document.getElementById('dropdown-menu')?.remove();
    alert('Settings panel would open here - theme options, notifications, etc.');
}

function openHelp() {
    document.getElementById('dropdown-menu')?.remove();
    alert('Help section would open here - FAQ, support, guides, etc.');
}

function exploreCharacter(character) {
    // Fix the character mapping
    let characterKey;
    switch(character) {
        case 'creaper':
            characterKey = 'creaperz';
            break;
        case 'dingbat':
            characterKey = 'dingbatz';
            break;
        case 'lilcreap':
            characterKey = 'lilcreapz';
            break;
        case 'grim':
            characterKey = 'grimz';
            break;
        default:
            characterKey = character + 's';
    }
    
    const nfts = collectionManager.getCharacterNFTs(characterKey);
    console.log(`Opening ${character} gallery with ${nfts.length} NFTs from key: ${characterKey}`);
            const displayNames = {
            'creaper': 'cReaperZ',
            'dingbat': 'DingbatZ', 
            'lilcreap': 'Lil cReapZ',
            'grim': 'GrimZ'
        };

        showCharacterGallery(displayNames[character] || character, nfts);
}

function showCharacterGallery(characterType, nfts) {
    const modal = document.createElement('div');
    modal.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.95);
        z-index: 3000;
        overflow-y: auto;
        padding: 20px;
    `;

    const content = `
        <div style="max-width: 1200px; margin: 0 auto;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 30px;">
                <h2 style="color: #00ffff; font-family: 'Spooky Ghoster', 'Creepster', cursive; font-size: 2.5rem; text-shadow: 0 0 10px #00ffff;">
                    ${characterType}
                </h2>
                <button onclick="this.closest('.modal').remove()" style="
                    background: linear-gradient(45deg, #ff4444, #cc3333);
                    border: 2px solid #ff6666;
                    color: white;
                    padding: 12px 24px;
                    border-radius: 8px;
                    cursor: pointer;
                    font-family: 'Chiller', cursive;
                    font-size: 1.1rem;
                    transition: all 0.3s ease;
                " onmouseover="this.style.transform='translateY(-2px)'" onmouseout="this.style.transform='translateY(0)'">
                    Close Gallery
                </button>
            </div>
            <div style="text-align: center; margin-bottom: 20px; color: #ccc; font-family: 'Chiller', cursive; font-size: 1.2rem;">
                ${nfts.length} unique ${characterType} discovered in the collection
            </div>
            <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(280px, 1fr)); gap: 25px;">
                ${nfts.map(nft => `
                    <div style="
                        background: rgba(0, 0, 0, 0.8);
                        border: 2px solid #00ffff;
                        border-radius: 15px;
                        padding: 20px;
                        text-align: center;
                        color: white;
                        transition: all 0.4s ease;
                        box-shadow: 0 0 15px rgba(0, 255, 255, 0.2);
                    " onmouseover="this.style.transform='translateY(-5px)'; this.style.boxShadow='0 0 25px rgba(0, 255, 255, 0.4)'" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 0 15px rgba(0, 255, 255, 0.2)'">
<div style="
    width: 100%;
    aspect-ratio: 1;
    background-image: url('${nft.image}');
    background-size: cover;
    background-position: center;
    background-repeat: no-repeat;
    background-color: linear-gradient(45deg, #1a1a1a, #333333);
    border: 2px solid rgba(0, 255, 255, 0.3);
    border-radius: 10px;
    margin-bottom: 15px;
    position: relative;
">
</div>
                        <h3 style="margin: 15px 0 10px 0; font-family: 'Chiller', cursive; font-size: 1.3rem; color: #00ffff;">${nft.name}</h3>
                        <div style="display: flex; flex-direction: column; gap: 5px; font-size: 0.9rem;">
                            <div style="color: getRarityColor('${nft.traits.rarity}'); font-weight: bold;">
                                ${nft.traits.rarity}
                            </div>
                            ${Object.entries(nft.traits).filter(([key]) => key !== 'rarity').map(([key, value]) => 
                                `<div style="color: #bbb;"><span style="color: #888;">${key}:</span> ${value}</div>`
                            ).join('')}
                        </div>
                    </div>
                `).join('')}
            </div>
        </div>
    `;

    modal.className = 'modal';
    modal.innerHTML = content;
    document.body.appendChild(modal);
}

function getCharacterEmoji(characterType) {
    const emojis = {
        'creaper': '💀',
        'dingbat': '🦇', 
        'lilcreap': '👻',
        'grim': '⚡'
    };
    return emojis[characterType] || '💀';
}

function getRarityColor(rarity) {
    const colors = {
        'Common': '#ffffff',
        'Rare': '#0099ff',
        'Legendary': '#ff6600',
        'Ultimate': '#9933ff',
        'Eternal': '#ff0066'
    };
    return colors[rarity] || '#ffffff';
}

function openLore() {
    alert('Opening the Lore archive...\nThis would contain all documented stories, character backgrounds, and realm history.');
}

function openSoulzConduit() {
    alert('Accessing the SoulZ Conduit...\nThis would open the rewards/vending machine interface we created!');
}

function openDrip() {
    window.open('https://drip.haus', '_blank');
}

// Auto-increment SoulZ for demo
let currentSoulz = 247;
setInterval(() => {
    if (Math.random() > 0.9) {
        let increment = Math.floor(Math.random() * 5) + 1;
        
        // Apply CNFT holder multiplier if applicable
        if (window.cnftHolderStatus && window.cnftHolderStatus.soulzMultiplier) {
            increment = Math.floor(increment * window.cnftHolderStatus.soulzMultiplier);
        }
        
        currentSoulz += increment;
        document.getElementById('soulzBalance').textContent = currentSoulz;
    }
}, 3000);

// Initialize collection manager
const collectionManager = new CollectionManager();

// Load collection data when page loads
document.addEventListener('DOMContentLoaded', () => {
    collectionManager.loadCollectionData();
});

</script>
</body>
</html>